[["index.html", "Spatial Analysis mit R (I) Methodenwoche Zeitplan", " Spatial Analysis mit R (I) Methodenwoche Till Straube Institut für Humangeographie Goethe-Universität Frankfurt straube@geo.uni-frankfurt.de 20.–21. September 2021 Zeitplan Alle Sitzungen finden über Zoom statt. Zeit Montag Dienstag 10:00–11:30 (1) Getting started (LAS) (5) Geodaten beschaffen 11:30–11:45 Kaffeepause Kaffeepause 11:45–13:15 (2) Daten visualisieren (FTR, HOS) (6) Geodaten verschneiden 13:15–14:15 Mittagspause Mittagspause 14:15–15:45 (3) Karten erstellen (FTR) (7) Weitere Methoden 15:45–16:15 Kaffeepause Kaffeepause 16:15–18:00 (4) Karten erstellen (HOS, SYW) (8) Publizieren und nach Hilfe fragen "],["getting-started.html", "Teil 1 Getting started 1.1 Formales 1.2 Inhaltliches 1.3 Didaktisches 1.4 Technisches", " Teil 1 Getting started 1.1 Formales 1.1.1 Keine reguläre Anrechnung des Workshops Die Methodenwoche ist eine außercurriculare Veranstaltung Keine Anrechnung als Prüfungsleistung für das reguläre Studium Alle Teilnehmer*innen erhalten Methodenzentrum eine Bescheinigung über die erbrachte Leistung (Ende 2021/Anfang 2022) 1.1.2 Methodenzertifikat Nur für Bachelor-Studierende der Fachbereiche 02–05 Kann mit 5 CP beantragt werden z. B. Teilnahme Workshop (2 CP) + Leistungsnachweis (3 CP) Maximal 20% Fehlzeit zulässig für Teilnahmenachweis Schriftliche Leistungsnachweise mit maximal vierwöchiger Abgabefrist Alle Fragen dazu bitte an hiwis-methodenzentrum@uni-frankfurt.de 1.1.3 Leistungsnachweis Schriftliche Ausarbeitung In Form eines kleinen Forschungsberichts: Thematische Einleitung Fragestellung Beschreibung der Datenquelle(n) Nachvollziehbare Bearbeitung der Daten Nachvollziehbare Visualisierung(en) Interpretation Format: Rmarkdown + (Roh-)datensatz 1.2 Inhaltliches 1.2.1 Lernziele der Veranstaltung Sie können… Datenvisualisierungen nachvollziehen und selbst gestalten. Geodaten einlesen, transformieren und verschneiden. Geodaten kartographisch darstellen. Reproducible examples erstellen um nach Hilfe zu fragen. Berichte in Rmarkdown verfassen und rendern. 1.2.2 Seminarkonzept Kompetenter Umgang mit Geodaten als Kernziel Aber nicht im luftleeren Raum Das Drumherum ist mindestens genauso wichtig Unterlagen sind Auszüge aus einem zweisemestrigen Seminar 1.2.3 Opinionated… package choices: tidyverse sf coding style: Functional Pipes %&gt;% workflow: Incremental commands Rmarkdown (reproducible research) 1.3 Didaktisches 1.3.1 Herausforderungen in der IT-Didaktik Unterschiedliche Erfahrungen, Kompetenzen und Herangehensweisen Die eine Hälfte versteht gar nichts, die andere langweilt sich Kleinster gemeinsamer Nenner: Schritt-für-Schritt-Anleitungen In der Praxis wertlos 1.3.2 Everyone fails In der Praxis stoßen alle ständig an die Grenzen ihrer technischen Kompetenz. Es geht darum, sich am Limit einigermaßen wohl zu fühlen und die Grenzen zu verschieben. Gute Angewohnheiten (Strukturen, Formate, Stil) helfen dabei! 1.3.3 Mein Ansatz in der Lehre Strategische Überforderung durch schwierige Aufgaben? Lösungsorientierte Didaktik! Die affektive Seite (Spaß, Frust) ernst nehmen und thematisieren Frustrationsschwelle trainieren 1.3.4 Schattenkompetenzen Über Code reden Fehlermeldungen lesen Gezielt googlen (und Antworten auswählen) Copy, paste, customize Gute Fragen (online) stellen 1.3.5 Dieser Workshop findet in verschiedenen Modi statt: 1.3.5.1 Listen and share (LAS) Ich rede (mit Folien oder ohne) oder moderiere eine Diskussion. Sie hören mir und Ihren Kommiliton*innen aufmerksam zu. Sie melden sich für Redebeiträge oder Fragen (Zoom-Funktion). 1.3.5.2 Follow the recipe (FTR) Ich teile ein unvollständiges Beispielprojekt. Wir gehen die Teilschritte nach und nach durch. Ich habe den Plan, stelle aber immer wieder Fragen ans Plenum. Sie vollziehen die Schritte an Ihrer eigenen Kopie des Projekts nach. Sie unterbrechen mich mit Nachfragen oder Problemen. 1.3.5.3 Hands-on session (HOS) Sie bearbeiten praktische Aufgabenstellungen alleine. Dabei sind sie in zufälligen Dreier-Konstellationen (Breakout-Session). Bei Fragen oder Problemen wenden Sie sich zunächst an Ihre Kleingruppe. Falls Sie nicht weiterkommen, fordern Sie Hilfe an (Zoom-Funktion). Ich reagiere auf Hilfegesuche oder mache die Runde. 1.3.5.4 Share your work (SYW) Ich wähle eine Teilnehmer*in zufällig aus. Die Person teilt ihren Bildschirm und berichtet von ihrer Bearbeitung eines Problems. Alle anderen unterstützen solidarisch durch aktives Nachvollziehen, Nachfragen und Hinweise. 1.4 Technisches 1.4.1 Arbeitsplatz Challenge: Zoom (meinen Bildschirm) und R gleichzeitig sehen Am allerbesten: Zweiter Bildschirm Auch gut: Zweites Gerät (Tablet) 1.4.2 Workshopunterlagen Bookdown (statt OLAT) Können Werden sich verändern Am besten neu laden mit Strg+Umschalt+R https://tiny.gu/mwsa 1.4.3 RStudio Cloud Grundsätzliche Empfehlung: R und RStudio lokal installieren Wir nutzen im Rahmen des Workshops die RStudio Cloud für einfaches Teilen von Code für ein homogenes Setup "],["daten-visualisieren.html", "Teil 2 Daten visualisieren 2.1 Lernziele dieser Sitzung 2.2 Voraussetzungen 2.3 Überblick 2.4 Visualisierung mit dem Standardpaket 2.5 Visualisierung mit ggplot() 2.6 Aufgaben", " Teil 2 Daten visualisieren 2.1 Lernziele dieser Sitzung Sie können… einfache Befehle zur Visualisierung in Base R anwenden. die Grammatik von ggplot2 für Visualisierungen in Grundzügen wiedergeben und anwenden. eigene Ideen für Visualisierungen entwickeln und umsetzen. 2.2 Voraussetzungen Für diese Lektion benötigen wir das Paket tidyverse: library(tidyverse) Und einen Datensatz, der in Form eines tibble vorliegt. Der Beispieldatensatz diamonds wird mitgeliefert: diamonds ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows Wenn wir mögen, können wir ihn mit der Funktion data() explizit in unser Environment laden: data(diamonds) 2.3 Überblick Einen ersten Überblick kriegen wir zum Einen durch den Befehl str(), der uns die Typen in den Spalten anzeigt: str(diamonds) ## tibble [53,940 × 10] (S3: tbl_df/tbl/data.frame) ## $ carat : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... ## $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... ## $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... ## $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... ## $ depth : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... ## $ table : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ... ## $ price : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ... ## $ x : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... ## $ y : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... ## $ z : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... Zum Anderen gibt die Hilfefunktion Auskunft über den Datensatz und die einzelnen Variablen (Metadaten): ?diamonds Einen Überblick über die wichtigsten statistischen Parameter erhalten wir mit: summary(diamonds) ## carat cut color clarity depth ## Min. :0.2000 Fair : 1610 D: 6775 SI1 :13065 Min. :43.00 ## 1st Qu.:0.4000 Good : 4906 E: 9797 VS2 :12258 1st Qu.:61.00 ## Median :0.7000 Very Good:12082 F: 9542 SI2 : 9194 Median :61.80 ## Mean :0.7979 Premium :13791 G:11292 VS1 : 8171 Mean :61.75 ## 3rd Qu.:1.0400 Ideal :21551 H: 8304 VVS2 : 5066 3rd Qu.:62.50 ## Max. :5.0100 I: 5422 VVS1 : 3655 Max. :79.00 ## J: 2808 (Other): 2531 ## table price x y ## Min. :43.00 Min. : 326 Min. : 0.000 Min. : 0.000 ## 1st Qu.:56.00 1st Qu.: 950 1st Qu.: 4.710 1st Qu.: 4.720 ## Median :57.00 Median : 2401 Median : 5.700 Median : 5.710 ## Mean :57.46 Mean : 3933 Mean : 5.731 Mean : 5.735 ## 3rd Qu.:59.00 3rd Qu.: 5324 3rd Qu.: 6.540 3rd Qu.: 6.540 ## Max. :95.00 Max. :18823 Max. :10.740 Max. :58.900 ## ## z ## Min. : 0.000 ## 1st Qu.: 2.910 ## Median : 3.530 ## Mean : 3.539 ## 3rd Qu.: 4.040 ## Max. :31.800 ## 2.4 Visualisierung mit dem Standardpaket Es gibt in R mehrere grundlegend verschiedene Möglichkeiten, Daten zu visualisieren. Für einen schnellen Überblick sind z.B. hist() und boxplot() hilfreich: hist(diamonds$price) boxplot(diamonds$x) 2.5 Visualisierung mit ggplot() Das Paket ggplot2 ist Teil vom tidyverse. Hiermit lassen sich sehr flexible Graphiken gestalten. Wir werden ausschließlich mit diesem System arbeiten. Die Syntax ist dabei auf den ersten Blick etwas komplexer. Am Anfang steht der Befehl ggplot(x) mit dem Datensatz als Parameter ggplot(data = diamonds) Mit einem Mapping-Parameter legen wir die Dimensionen fest: ggplot(data = diamonds, mapping = aes(x = price, y = carat)) Das gleiche ohne Parameternamen: ggplot(diamonds, aes(price, carat)) Nun kann mit dem +-Operator ein geometrischer Layer hinzugefügt werden: ggplot(diamonds, aes(x = carat, y = price)) + geom_point() Weitere geom-Layer lassen sich mit dem +-Operator hinzufügen: ggplot(diamonds, aes(x = carat, y = price)) + geom_point() + geom_smooth() Die Layer-Funktionen können durch Parameter angepasst werden: ggplot(diamonds, aes(x = carat, y = price)) + geom_point(size = 0.5) + geom_smooth(color = &quot;red&quot;) Dabei lassen sich in den einzelnen Layers mappings hinzufügen oder verändern: ggplot(diamonds, aes(x = carat, y = price)) + geom_point(aes(color = clarity), size = 0.5) + geom_smooth(color = &quot;red&quot;) Schließlich lassen sich noch viele weitere optische Aspekte anpassen, z.B. Achsen, Farben, etc.: ggplot(diamonds, aes(x = carat, y = price)) + geom_point(aes(color = clarity), size = 0.5) + geom_smooth(color = &quot;red&quot;) + scale_x_continuous(&quot;Karatzahl&quot;, breaks = seq(0, 5, 0.5)) + scale_y_continuous(&quot;Preis&quot;) + scale_color_brewer(&quot;Klarheit&quot;) + theme_dark() 2.6 Aufgaben Versuchen Sie, die folgenden Visualisierungen des Datensatzes diamonds auszugeben: ggplot(diamonds, aes(x = cut)) + geom_bar(aes(fill = color)) ggplot(diamonds, aes(x = depth, y = price)) + geom_point(alpha = 0.1, aes(color = cut)) + guides(colour = guide_legend(override.aes = list(alpha = 1))) ggplot(diamonds, aes(x = color, y = price)) + geom_boxplot(aes(color = color), outlier.colour = NA) + facet_wrap(~cut) + theme(legend.position = &quot;none&quot;) + scale_x_discrete(&quot;Farbe&quot;) + scale_y_continuous(&quot;Preis&quot;) Schauen Sie sich die Publikation R for Data Science an. Was ist das für ein Buch? Wer ist das Zielpublikum? Lesen Sie das Kapitel 3: Data Visualization und vollziehen Sie die Visualisierungen nach. Bearbeiten Sie die Aufgaben. Bearbeiten Sie die RStudio Primers zu Datenvisualisierung. "],["karten-erstellen-ftr.html", "Teil 3 Karten erstellen (FTR) 3.1 Lernziele dieser Sitzung 3.2 Voraussetzungen 3.3 Exkurs: Pipes 3.4 Daten importieren 3.5 Überblick verschaffen 3.6 Visualisieren", " Teil 3 Karten erstellen (FTR) 3.1 Lernziele dieser Sitzung Sie können… Pipes benutzen einfache dplyr-Befehle ausführen Koordinaten visualisieren 3.2 Voraussetzungen Wir laden erstmal tidyverse: library(tidyverse) 3.3 Exkurs: Pipes Teil vom tidyverse ist auch das Paket magrittr, das einen besonderen Operator enthält: %&gt;% Der Operator %&gt;% heißt Pipe und setzt das Ergebnis der vorherigen Funktion als ersten Parameter in die nächste Funktion ein. Zur Veranschaulichung: anzahl_buchstaben &lt;- length(letters) sqrt(anzahl_buchstaben) …ist das gleiche wie… sqrt(length(letters)) …ist das gleiche wie… length(letters) %&gt;% sqrt() …ist das gleiche wie… letters %&gt;% length %&gt;% sqrt() So können beliebig viele Funktionen aneinandergereiht werden. Und mit -&gt; kann eine Variable „in die andere Richtung“ zugewiesen werden letters %&gt;% length() %&gt;% sqrt() %&gt;% round() %&gt;% as.character() -&gt; my_var Gerade bei komplizierteren Zusammenhängen wird der Code so oft lesbarer, weil die Logik von links nach rechts, bzw. von oben nach unten gelesen werden kann. 3.4 Daten importieren Beim Open-Data-Portal der Stadt Frankfurt steht ein Baumkataster zur Verfügung. Die Datei im CSV-Format (comma separated values) kann entweder heruntergeladen und durch klicken importiert werden, oder direkt über den Befehl: baumkataster &lt;- read_csv2(&quot;http://offenedaten.frankfurt.de/dataset/73c5a6b3-c033-4dad-bb7d-8783427dd233/resource/7a73520b-961a-4aad-a582-449e676c247c/download/gprojekteopen-datadatenamt-67datenbaumauswahl_veroffentlichung_4baumauswahl_veroffentlichung_4.csv&quot;) 3.5 Überblick verschaffen Mit summary() lässt sich eine Zusammenfassung der Werte generieren: summary(baumkataster) ## Gattung/Art/Deutscher Name Baumnummer Objekt Pflanzjahr ## Length:118403 Min. : 1.0 Length:118403 Min. :1645 ## Class :character 1st Qu.: 24.0 Class :character 1st Qu.:1970 ## Mode :character Median : 82.0 Mode :character Median :1982 ## Mean : 232.7 Mean :1979 ## 3rd Qu.: 270.0 3rd Qu.:1995 ## Max. :20158.0 Max. :2017 ## NA&#39;s :1853 ## Kronendurchmesser HOCHWERT RECHTSWERT ## Min. : 2.000 Min. :5545117 Min. :463163 ## 1st Qu.: 4.000 1st Qu.:5550428 1st Qu.:472715 ## Median : 6.000 Median :5552601 Median :475219 ## Mean : 6.688 Mean :5552953 Mean :475244 ## 3rd Qu.: 9.000 3rd Qu.:5555165 3rd Qu.:478201 ## Max. :63.000 Max. :5563639 Max. :485361 ## Genauere Infos über diese Merkmale gibt es auf dem Datenportal. 3.6 Visualisieren Wie in der letzten Lektion besprochen, lässt sich der Datensatz mit ggplot() visualisieren, z. B.: ggplot(baumkataster, aes(x = Kronendurchmesser)) + geom_histogram() Eine neue Messreihe lässt sich z. B. so errechnen: alter &lt;- 2020 - baumkataster$Pflanzjahr head(alter) ## [1] 100 100 100 100 100 100 Der Befehl mutate() funktioniert sehr ähnlich, gibt aber den veränderten Datensatz zurück: mutate(baumkataster, alter = 2020 - Pflanzjahr) ## # A tibble: 118,403 x 8 ## `Gattung/Art/Deutsch… Baumnummer Objekt Pflanzjahr Kronendurchmess… HOCHWERT ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Platanus x hispanica… 1 Ackerm… 1920 8 5549511. ## 2 Platanus x hispanica… 2 Ackerm… 1920 8 5549517. ## 3 Platanus x hispanica… 3 Ackerm… 1920 8 5549524. ## 4 Platanus x hispanica… 4 Ackerm… 1920 8 5549531 ## 5 Platanus x hispanica… 5 Ackerm… 1920 8 5549538. ## 6 Platanus x hispanica… 6 Ackerm… 1920 8 5549544. ## 7 Platanus x hispanica… 7 Ackerm… 1920 8 5549551. ## 8 Platanus x hispanica… 8 Ackerm… 1920 8 5549557. ## 9 Platanus x hispanica… 9 Ackerm… 1920 8 5549564. ## 10 Platanus x hispanica… 10 Ackerm… 1920 8 5549571. ## # … with 118,393 more rows, and 2 more variables: RECHTSWERT &lt;dbl&gt;, alter &lt;dbl&gt; Derselbe Befehl mit dem Pipe-Operator: baumkataster %&gt;% mutate(alter = 2020 - Pflanzjahr) ## # A tibble: 118,403 x 8 ## `Gattung/Art/Deutsch… Baumnummer Objekt Pflanzjahr Kronendurchmess… HOCHWERT ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Platanus x hispanica… 1 Ackerm… 1920 8 5549511. ## 2 Platanus x hispanica… 2 Ackerm… 1920 8 5549517. ## 3 Platanus x hispanica… 3 Ackerm… 1920 8 5549524. ## 4 Platanus x hispanica… 4 Ackerm… 1920 8 5549531 ## 5 Platanus x hispanica… 5 Ackerm… 1920 8 5549538. ## 6 Platanus x hispanica… 6 Ackerm… 1920 8 5549544. ## 7 Platanus x hispanica… 7 Ackerm… 1920 8 5549551. ## 8 Platanus x hispanica… 8 Ackerm… 1920 8 5549557. ## 9 Platanus x hispanica… 9 Ackerm… 1920 8 5549564. ## 10 Platanus x hispanica… 10 Ackerm… 1920 8 5549571. ## # … with 118,393 more rows, and 2 more variables: RECHTSWERT &lt;dbl&gt;, alter &lt;dbl&gt; So lassen sich auch hier verschiedene Befehle verknüpfen. filter() beschränkt den Datensatz auf Merkmalsträger, die den Kriterien entsprechen: baumkataster %&gt;% mutate(alter = 2020 - Pflanzjahr) %&gt;% filter(alter &gt; 30) -&gt; alte_baeume summary(alte_baeume) ## Gattung/Art/Deutscher Name Baumnummer Objekt Pflanzjahr ## Length:73859 Min. : 1.0 Length:73859 Min. :1645 ## Class :character 1st Qu.: 29.0 Class :character 1st Qu.:1960 ## Mode :character Median : 97.0 Mode :character Median :1974 ## Mean : 263.2 Mean :1966 ## 3rd Qu.: 314.0 3rd Qu.:1980 ## Max. :10489.0 Max. :1989 ## NA&#39;s :684 ## Kronendurchmesser HOCHWERT RECHTSWERT alter ## Min. : 2.000 Min. :5545117 Min. :463163 Min. : 31.00 ## 1st Qu.: 6.000 1st Qu.:5550415 1st Qu.:472667 1st Qu.: 40.00 ## Median : 8.000 Median :5552480 Median :475708 Median : 46.00 ## Mean : 8.503 Mean :5552593 Mean :475402 Mean : 53.54 ## 3rd Qu.:10.000 3rd Qu.:5554589 3rd Qu.:478539 3rd Qu.: 60.00 ## Max. :35.000 Max. :5563639 Max. :485360 Max. :375.00 ## Schließlich ergibt das Streudiagramm von Koordinaten so eine art Karte: ggplot(alte_baeume) + geom_point(size = 0.1, aes(x = RECHTSWERT, y = HOCHWERT)) Diesen Ansatz werden wir in der nächsten Lektion vertiefen. "],["karten-erstellen-hos.html", "Teil 4 Karten erstellen (HOS) 4.1 Aufgaben", " Teil 4 Karten erstellen (HOS) 4.1 Aufgaben Besuchen Sie https://pleiades.stoa.org/ - worum geht es hier? Finden Sie den kompletten aktuellen Datensatz für „locations“ als CSV-Datei. Importieren Sie ihn in R und weisen Sie dem Datensatz den Namen pleiades zu. pleiades &lt;- read_csv(&quot;http://atlantides.org/downloads/pleiades/dumps/pleiades-locations-latest.csv.gz&quot;) Finden Sie geeignete Werte für (einzelne) Längen- und Breitengrade im Datensatz. pleiades$reprLong %&gt;% # Längengrad summary() ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## -16.910 8.013 16.929 19.819 30.730 111.078 7292 pleiades$reprLat %&gt;% # Breitengrad summary() ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## -20.27 36.25 39.17 39.55 43.72 62.50 7292 Plotten Sie die Koordinaten auf x- und y-Achse mit ggplot(). Was erkennen Sie? ggplot(pleiades) + geom_point(aes(x = reprLong, y = reprLat)) Halbieren Sie die Größe und setzen Sie den Alpha-Wert der Punkte auf 0,2. ggplot(pleiades) + geom_point(aes(x = reprLong, y = reprLat), size = 0.5, alpha = 0.2) Bringen Sie die Grafik in die Mercator-Projektion. ggplot(pleiades) + geom_point(aes(x = reprLong, y = reprLat), size = 0.5, alpha = 0.2) + coord_map(&quot;mercator&quot;) Schauen Sie sich diesen Befehl an: map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group)) + coord_quickmap(xlim = c(-8, 40), ylim = c(26, 48)) Versuchen Sie, jede einzelne Zeile nachzuvollziehen, indem Sie die entsprechenden Funktionen recherchieren. Führen Sie den Befehl aus. Ändern Sie die Farbe der Flächen in hellgrau. map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group), fill = &quot;grey&quot;) + coord_quickmap(xlim = c(-8, 40), ylim = c(26, 48)) Wählen Sie einen Kartenausschnitt, auf dem Portugal, Ägypten, Irak und Frankreich komplett zu sehen sind. map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group), fill = &quot;grey&quot;) + coord_quickmap(xlim = c(-8, 48), ylim = c(22, 50)) Plotten Sie auf diesem Hintergrund den Datensatz pleiades. Passen Sie dabei die Parameter so an, dass es Ihnen optisch zusagt. map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group), fill = &quot;grey&quot;) + coord_quickmap(xlim = c(-8, 48), ylim = c(22, 50)) + geom_point(data = pleiades, mapping = aes(x = reprLong, y = reprLat), color = &quot;blue&quot;, size = 0.3, alpha = 0.5) Wählen Sie für die Karte die Bonnesche Projektion mit Standardparallele bei 40°N. map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group), fill = &quot;grey&quot;) + coord_map(&quot;bonne&quot;, 40, xlim = c(-8, 48), ylim = c(22, 50)) + geom_point(data = pleiades, mapping = aes(x = reprLong, y = reprLat), color = &quot;blue&quot;, size = 0.3, alpha = 0.5) Entfernen Sie alle Achsenbeschriftungen. map_data(&quot;world&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(x = long, y = lat, group = group), fill = &quot;grey&quot;) + coord_map(&quot;bonne&quot;, 40, xlim = c(-8, 48), ylim = c(22, 50)) + geom_point(data = pleiades, mapping = aes(x = reprLong, y = reprLat), color = &quot;blue&quot;, size = 0.3, alpha = 0.5) + theme(axis.title = element_blank(), axis.ticks = element_blank(), axis.text = element_blank()) (Achtung: knifflig!) Bilden Sie diese Grafik nach, die die Orte geordnet nach ältestem Fund darstellt: pleiades %&gt;% select(long = reprLong, lat = reprLat, timePeriods) %&gt;% mutate(oldest = str_extract(timePeriods, &quot;[ACHRL]&quot;)) %&gt;% mutate(oldest = factor(oldest, levels = c(&quot;A&quot;, &quot;C&quot;, &quot;H&quot;, &quot;R&quot;, &quot;L&quot;))) -&gt; pleiades_periods map_data(&quot;world&quot;) %&gt;% filter(region != &quot;Antarctica&quot;) %&gt;% ggplot() + geom_polygon(mapping = aes(long, lat, group = group), fill = &quot;darkgreen&quot;) + coord_map(&quot;albers&quot;, parameters = c(16, 37), xlim = c(-8, 40), ylim = c(26, 48)) + geom_point(data = pleiades_periods, mapping = aes(long, lat, color = oldest), size = 0.2, alpha = 0.3) + scale_color_brewer(&quot;Früheste Epoche&quot;, breaks = c(&quot;A&quot;, &quot;C&quot;, &quot;H&quot;, &quot;R&quot;, &quot;L&quot;), labels = c(&quot;1000-550 v.d.Z.&quot;, &quot;550-330 v.d.Z.&quot;, &quot;330 v.d.Z. - 30 n.d.Z.&quot;, &quot;30-300 n.d.Z.&quot;, &quot;300-640 n.d.Z.&quot;), palette = &quot;YlOrBr&quot;) + theme(axis.title = element_blank(), axis.ticks = element_blank(), axis.text = element_blank(), panel.background = element_rect(fill = &quot;darkblue&quot;), panel.grid = element_line(color = &quot;blue&quot;)) + guides(colour = guide_legend(override.aes = list(alpha = 1, size = 8, shape = 15))) "],["geodaten-beschaffen.html", "Teil 5 Geodaten beschaffen 5.1 Lernziele dieser Sitzung 5.2 Vorbereitung 5.3 Datenbeschaffung 5.4 Datenformatierung 5.5 Datenaufbereitung 5.6 Datenvisualisierung 5.7 Aufgaben", " Teil 5 Geodaten beschaffen 5.1 Lernziele dieser Sitzung Sie können… sich den Quellcode einer Webseite anzeigen lassen und interpretieren. HTML-Tabellen als Datensatz einlesen. Fortgeschrittene Methoden der Datenbereinigung nachvollziehen. 5.2 Vorbereitung Am Beispiel der Küstenlängen verschiedener Länder besprechen wir Techniken der Datenerhebung/-erfassung und -visualisierung. Unser Ziel ist es, die Daten zu den Küstenlängen in einer Grafik darzustellen. Für die folgenden Aufgaben benötigen wir die Pakete rvest und tidyverse. Zunächst müssen diese installiert und in unsere Umgebung geladen werden. library(tidyverse) library(rvest) 5.3 Datenbeschaffung Auf dem Internetauftritt der CIA gab es es eine Tabelle, welche die Küstenlänge (inklusive der Inseln) der einzelnen Länder enthält. Über die Archivierungsplattform WayBackMachine ist die Seite immer noch abrufbar: https://web.archive.org/web/20190802010710/https://www.cia.gov/library/publications/the-world-factbook/fields/282.html In einem ersten Schritt wird die URL der Tabelle der Variable url zugewiesen, sodass der Quellcode mit dem Befehl read_html() eingelesen werden kann. url &lt;- &quot;https://web.archive.org/web/20190802010710/https://www.cia.gov/library/publications/the-world-factbook/fields/282.html&quot; reply &lt;- read_html(url) Der Befehl html_table() ermöglicht das Auslesen aller Tabellen auf der Seite. Mithilfe des Befehls str() sehen wir, dass die Seite genau eine Tabelle enthält, welche die Informationen zu den Küstenlängen enthält. tables &lt;- html_table(reply, fill = TRUE) str(tables) ## List of 1 ## $ : tibble [266 × 2] (S3: tbl_df/tbl/data.frame) ## ..$ Country : chr [1:266] &quot;Afghanistan&quot; &quot;Akrotiri&quot; &quot;Albania&quot; &quot;Algeria&quot; ... ## ..$ Coastline: chr [1:266] &quot;0 km\\n (landlocked)&quot; &quot;56.3 km&quot; &quot;362 km&quot; &quot;998 km&quot; ... Durch die Umformung zu einem tibble erhalten wir eine Tabelle mit den gewünschten Informationen: as_tibble(tables[[1]]) ## # A tibble: 266 x 2 ## Country Coastline ## &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan &quot;0 km\\n (landlocked)&quot; ## 2 Akrotiri &quot;56.3 km&quot; ## 3 Albania &quot;362 km&quot; ## 4 Algeria &quot;998 km&quot; ## 5 American Samoa &quot;116 km&quot; ## 6 Andorra &quot;0 km\\n (landlocked)&quot; ## 7 Angola &quot;1,600 km&quot; ## 8 Anguilla &quot;61 km&quot; ## 9 Antarctica &quot;17,968 km&quot; ## 10 Antigua and Barbuda &quot;153 km&quot; ## # … with 256 more rows Mit pipes können wir die obigen Befehle zusammenfassen und somit das Ganze auf einmal ausführen. &quot;https://web.archive.org/web/20190802010710/https://www.cia.gov/library/publications/the-world-factbook/fields/282.html&quot; %&gt;% read_html() %&gt;% html_table(fill = T) %&gt;% .[[1]] %&gt;% as_tibble() -&gt; coast 5.4 Datenformatierung Zur Datenformatierung nutzen wir Funktionen aus dem Paket stringr. Die Spalte mit der Küstenlänge soll keinen Text, keine Einheit direkt hinter den Zahlenwerten und keine Kommata zur Trennung der Zahlenwerte enthalten. Der Befehl str_extract() sucht nach vorgegebenen Mustern (engl. patterns) und wählt diese aus. Diese patterns werden auch reguläre Ausdrücke (regular expressions / regex) genannt und sind eigentlich ein Thema für sich. Das Pattern [0-9,.]+ km extrahiert die Kilometerangaben. km &lt;- str_extract(coast$Coastline, &quot;[0-9,.]+ km&quot;) Die ausgewählten Muster (in unserem Fall Kommata und Text) können durch den Befehl str_replace_all() gelöscht oder ersetzt werden. Wir ersetzen alle Zeichen außer Zahlen und Dezimalpunkt mit einem leeren String, so dass sie verschwinden. str_replace_all(km, &quot;[^0-9.]&quot;, &quot;&quot;) ## [1] &quot;0&quot; &quot;56.3&quot; &quot;362&quot; &quot;998&quot; &quot;116&quot; &quot;0&quot; &quot;1600&quot; ## [8] &quot;61&quot; &quot;17968&quot; &quot;153&quot; &quot;45389&quot; &quot;4989&quot; &quot;0&quot; &quot;68.5&quot; ## [15] &quot;74.1&quot; &quot;111866&quot; &quot;25760&quot; &quot;0&quot; &quot;0&quot; &quot;3542&quot; &quot;161&quot; ## [22] &quot;580&quot; &quot;97&quot; &quot;0&quot; &quot;66.5&quot; &quot;386&quot; &quot;121&quot; &quot;103&quot; ## [29] &quot;0&quot; &quot;0&quot; &quot;20&quot; &quot;0&quot; &quot;29.6&quot; &quot;7491&quot; &quot;698&quot; ## [36] &quot;80&quot; &quot;161&quot; &quot;354&quot; &quot;0&quot; &quot;1930&quot; &quot;0&quot; &quot;965&quot; ## [43] &quot;443&quot; &quot;402&quot; &quot;202080&quot; &quot;160&quot; &quot;0&quot; &quot;0&quot; &quot;6435&quot; ## [50] &quot;14500&quot; &quot;138.9&quot; &quot;11.1&quot; &quot;26&quot; &quot;3208&quot; &quot;340&quot; &quot;37&quot; ## [57] &quot;169&quot; &quot;120&quot; &quot;3095&quot; &quot;1290&quot; &quot;515&quot; &quot;5835&quot; &quot;3735&quot; ## [64] &quot;364&quot; &quot;648&quot; &quot;0&quot; &quot;7314&quot; &quot;27.5&quot; &quot;314&quot; &quot;148&quot; ## [71] &quot;1288&quot; &quot;2237&quot; &quot;2450&quot; &quot;307&quot; &quot;296&quot; &quot;2234&quot; &quot;3794&quot; ## [78] &quot;0&quot; &quot;0&quot; &quot;65992.9&quot; &quot;1288&quot; &quot;1117&quot; &quot;1129&quot; &quot;1250&quot; ## [85] &quot;4853&quot; &quot;2525&quot; &quot;28&quot; &quot;885&quot; &quot;80&quot; &quot;40&quot; &quot;310&quot; ## [92] &quot;2389&quot; &quot;539&quot; &quot;12&quot; &quot;13676&quot; &quot;44087&quot; &quot;121&quot; &quot;125.5&quot; ## [99] &quot;400&quot; &quot;50&quot; &quot;320&quot; &quot;350&quot; &quot;459&quot; &quot;1771&quot; &quot;101.9&quot; ## [106] &quot;0&quot; &quot;823&quot; &quot;733&quot; &quot;6.4&quot; &quot;0&quot; &quot;4970&quot; &quot;7000&quot; ## [113] &quot;66526&quot; &quot;54716&quot; &quot;2440&quot; &quot;58&quot; &quot;1448&quot; &quot;160&quot; &quot;273&quot; ## [120] &quot;7600&quot; &quot;1022&quot; &quot;124.1&quot; &quot;29751&quot; &quot;8&quot; &quot;70&quot; &quot;34&quot; ## [127] &quot;26&quot; &quot;0&quot; &quot;536&quot; &quot;3&quot; &quot;1143&quot; &quot;2495&quot; &quot;2413&quot; ## [134] &quot;0&quot; &quot;499&quot; &quot;0&quot; &quot;0&quot; &quot;498&quot; &quot;225&quot; &quot;0&quot; ## [141] &quot;579&quot; &quot;1770&quot; &quot;0&quot; &quot;90&quot; &quot;0&quot; &quot;41&quot; &quot;4828&quot; ## [148] &quot;0&quot; &quot;4675&quot; &quot;644&quot; &quot;0&quot; &quot;196.8&quot; &quot;370.4&quot; &quot;754&quot; ## [155] &quot;177&quot; &quot;9330&quot; &quot;6112&quot; &quot;15&quot; &quot;0&quot; &quot;4.1&quot; &quot;0&quot; ## [162] &quot;293.5&quot; &quot;40&quot; &quot;1835&quot; &quot;2470&quot; &quot;1572&quot; &quot;30&quot; &quot;8&quot; ## [169] &quot;0&quot; &quot;451&quot; &quot;2254&quot; &quot;15134&quot; &quot;910&quot; &quot;0&quot; &quot;853&quot; ## [176] &quot;64&quot; &quot;32&quot; &quot;0&quot; &quot;1482&quot; &quot;25148&quot; &quot;2092&quot; &quot;135663&quot; ## [183] &quot;1046&quot; &quot;1519&quot; &quot;14.5&quot; &quot;2490&quot; &quot;5152&quot; &quot;518&quot; &quot;0&quot; ## [190] &quot;2414&quot; &quot;36289&quot; &quot;51&quot; &quot;440&quot; &quot;1793&quot; &quot;501&quot; &quot;563&quot; ## [197] &quot;225&quot; &quot;37653&quot; &quot;0&quot; &quot;60&quot; &quot;135&quot; &quot;158&quot; &quot;58.9&quot; ## [204] &quot;120&quot; &quot;84&quot; &quot;403&quot; &quot;0&quot; &quot;209&quot; &quot;2640&quot; &quot;531&quot; ## [211] &quot;0&quot; &quot;491&quot; &quot;402&quot; &quot;193&quot; &quot;58.9&quot; &quot;0&quot; &quot;46.6&quot; ## [218] &quot;5313&quot; &quot;3025&quot; &quot;2798&quot; NA &quot;0&quot; &quot;17968&quot; &quot;4964&quot; ## [225] &quot;926&quot; &quot;1340&quot; &quot;853&quot; &quot;386&quot; &quot;3587&quot; &quot;3218&quot; &quot;0&quot; ## [232] &quot;193&quot; &quot;1566.3&quot; &quot;0&quot; &quot;1424&quot; &quot;3219&quot; &quot;706&quot; &quot;56&quot; ## [239] &quot;101&quot; &quot;419&quot; &quot;362&quot; &quot;1148&quot; &quot;7200&quot; &quot;0&quot; &quot;389&quot; ## [246] &quot;24&quot; &quot;0&quot; &quot;2782&quot; &quot;1318&quot; &quot;12429&quot; &quot;19924&quot; &quot;4.8&quot; ## [253] &quot;660&quot; &quot;0&quot; &quot;2528&quot; &quot;2800&quot; &quot;3444&quot; &quot;188&quot; &quot;19.3&quot; ## [260] &quot;129&quot; &quot;0&quot; &quot;1110&quot; &quot;356000&quot; &quot;1906&quot; &quot;0&quot; &quot;0&quot; Auch hier kann alles in einen Befehl gepackt werden: coast$Coastline %&gt;% str_extract(&quot;[0-9,.]+ km&quot;) %&gt;% str_replace_all(&quot;[^0-9.]&quot;, &quot;&quot;) %&gt;% as.numeric() -&gt; coast$coast_num 5.5 Datenaufbereitung Mit dem Befehl arrange() kann die Tabelle sortiert werden. Zunächst auftseigend, coast %&gt;% arrange(coast_num) ## # A tibble: 266 x 3 ## Country Coastline coast_num ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan &quot;0 km\\n (landlocked)&quot; 0 ## 2 Andorra &quot;0 km\\n (landlocked)&quot; 0 ## 3 Armenia &quot;0 km\\n (landlocked)&quot; 0 ## 4 Austria &quot;0 km\\n (landlocked)&quot; 0 ## 5 Azerbaijan &quot;0 km\\n (landlocked); note - Azerbaijan borde… 0 ## 6 Belarus &quot;0 km\\n (landlocked)&quot; 0 ## 7 Bhutan &quot;0 km\\n (landlocked)&quot; 0 ## 8 Bolivia &quot;0 km\\n (landlocked)&quot; 0 ## 9 Botswana &quot;0 km\\n (landlocked)&quot; 0 ## 10 Burkina Fa… &quot;0 km\\n (landlocked)&quot; 0 ## # … with 256 more rows und schließlich absteigend, sodass die größten Werte an erster Stelle stehen. coast %&gt;% arrange(desc(coast_num)) ## # A tibble: 266 x 3 ## Country Coastline coast_num ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 World &quot;356,000 km\\n \\n \\n \\n\\n \\n… 356000 ## 2 Canada &quot;202,080 km\\n \\n \\n \\n\\n \\n… 202080 ## 3 Pacific Oce… &quot;135,663 km&quot; 135663 ## 4 Atlantic Oc… &quot;111,866 km&quot; 111866 ## 5 Indian Ocean &quot;66,526 km&quot; 66526 ## 6 European Un… &quot;65,992.9 km&quot; 65993. ## 7 Indonesia &quot;54,716 km&quot; 54716 ## 8 Arctic Ocean &quot;45,389 km&quot; 45389 ## 9 Greenland &quot;44,087 km&quot; 44087 ## 10 Russia &quot;37,653 km&quot; 37653 ## # … with 256 more rows Bevor wir jedoch eine vollständig sortierte Liste haben, muss der Datensatz noch von falschen Einträgen gesäubert werden. Dafür benutzen wir den Befehl filter(). Wir suchen wieder nach einem bestimmten Muster (hier zum Beispiel dem Wort Ocean) und filtern es aus dem Datensatz. Die Grafik soll nur aus den ersten 30 Einträgen der Tabelle bestehen, welche uns der Befehl head() ausgibt. coast %&gt;% arrange(desc(coast_num)) %&gt;% filter(!str_detect(Country, &quot;Ocean&quot;)) %&gt;% filter(!Country %in% c(&quot;World&quot;, &quot;European Union&quot;)) %&gt;% head(30) -&gt; top_30 5.6 Datenvisualisierung Das Balkendiagramm erhalten wir durch den ggplot Befehl. Hierbei gibt es verschiedenste Einstellmöglichkeiten. Wichitg sind vor allem die Angabe des verwendeten Datensatzes und die Art der Grafik (ob Kartendarstellung oder Balkendiagramm). Desweiteren kann man noch Farben der Eigenschaften, eine Achsenbeschriftung u. v. m. bestimmen. ggplot(top_30, aes(x = reorder(Country, coast_num), y=coast_num)) + geom_bar(stat=&#39;identity&#39;, fill=&quot;darkblue&quot;) + coord_flip() + scale_x_discrete(NULL) + scale_y_continuous(&quot;Küstenlinie (km)&quot;) 5.7 Aufgaben Importieren Sie die Daten zu den tödlichen Erdbeben auf Wikipedia und formen sie diese zu einem tibble um. &quot;https://en.wikipedia.org/wiki/List_of_deadly_earthquakes_since_1900&quot; %&gt;% read_html %&gt;% html_table(fill = T) %&gt;% .[[5]] %&gt;% as.tibble() -&gt; earthquakes_raw Erstellen Sie mit den erhaltenen Daten eine Karte, welche die Lage und die Stärke der Erdbeben angibt: earthquakes_raw %&gt;% mutate(Lat = as.numeric(Lat), Long = as.numeric(Long)) %&gt;% mutate(magnitude_num = as.numeric(str_extract(Magnitude, &quot;[0-9.]+&quot;))) -&gt; earthquakes ggplot() + geom_polygon(data = map_data(&quot;world&quot;), aes(x = long, y = lat, group = group)) + geom_point(data = earthquakes, aes(x = Long, y = Lat, size = magnitude_num), color = &quot;red&quot;, alpha = 0.1) + coord_quickmap() + scale_size_area(&quot;Stärke&quot;) Wandeln Sie den Erdbeben-Datensatz in das Simple Features Format um. Laden Sie zusätzlich eine Weltkarte mit dem Paket rnaturalearth und wandeln Sie auch diese in Simple Features um. Finden Sie außerdem einen Geodatensatz zu tektonischen Platten. Visualiseren Sie alles auf einer Welktarte (Projektion: Gall-Peters). library(sf) earthquakes %&gt;% filter(! is.na(Long)) %&gt;% st_as_sf(coords=c(&quot;Long&quot;, &quot;Lat&quot;)) %&gt;% st_set_crs(4326) -&gt; quakesf library(rnaturalearth) ne_download(type=&quot;land&quot;, category = &quot;physical&quot;) %&gt;% st_as_sf() %&gt;% st_transform(&#39;+proj=cea +lon_0=0 +x_0=0 +y_0=0 +lat_ts=45 +ellps=WGS84 +datum=WGS84 +units=m +no_defs&#39;) -&gt; earthsf st_read(&quot;https://raw.githubusercontent.com/fraxen/tectonicplates/master/GeoJSON/PB2002_plates.json&quot;) -&gt; plates ggplot() + geom_sf(data = earthsf, fill = &quot;gray&quot;, color = NA) + geom_sf(size = 1, data = quakesf, color = &quot;red&quot;, alpha = 0.1) + geom_sf(data = plates, color = &quot;orange&quot;, fill = NA, lwd = 0.3) "],["geodaten-verschneiden.html", "Teil 6 Geodaten verschneiden 6.1 Lernziele 6.2 Vorbereitung 6.3 Ziel 6.4 Grundkarte 6.5 OSM-Daten 6.6 Koordinatenreferenzsysteme 6.7 Verschneiden 6.8 Aufgaben", " Teil 6 Geodaten verschneiden 6.1 Lernziele Sie können… Geodaten als Simple Features importieren, CRS bestimmen und umwandeln, einfache Verschneidungen von Simple Features durchführen und Simple Features kartographisch darstellen. 6.2 Vorbereitung Für diese Lektion werden zwei Pakete geladen: library(tidyverse) library(sf) 6.3 Ziel Ziel ist, eine Choroplethenkarte von Frankfurt zu erstellen, die die Versorgung mit Kiosken darstellt. 6.4 Grundkarte Eine Shapefile der Frankfurter Stadtteile findet sich hier: http://www.offenedaten.frankfurt.de/dataset/frankfurter-stadtteilgrenzen-fur-gis-systeme Wir laden die Zip-Datei herunter und speichern den enthaltenen Ordner stadtteile in unserem Arbeitsverzeichnis. Es ist eine gute Angewohnheit, einen Unterordner für Ressourcen anzulegen. Dann importieren wir den Geodatensatz als Simple Features (Paket sf): stadtteile &lt;- st_read(&quot;resources/stadtteile/Stadtteile_Frankfurt_am_Main.shp&quot;) ## Reading layer `Stadtteile_Frankfurt_am_Main&#39; from data source ## `/Users/till/mzs/2021_methodenwoche/skript/resources/stadtteile/Stadtteile_Frankfurt_am_Main.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 46 features and 2 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 462292.7 ymin: 5540412 xmax: 485744.8 ymax: 5563925 ## Projected CRS: ETRS89 / UTM zone 32N Simple Features sind Datensätze, die eine Spalte geometry enthalten, in der Geodaten in einem standardisierten Format hinterlegt sind. str(stadtteile) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 46 obs. of 3 variables: ## $ STTLNR : num 1 2 3 4 5 6 7 8 9 10 ... ## $ STTLNAME: chr &quot;Altstadt&quot; &quot;Innenstadt&quot; &quot;Bahnhofsviertel&quot; &quot;Westend-Süd&quot; ... ## $ geometry:sfc_POLYGON of length 46; first list element: List of 1 ## ..$ : num [1:46, 1:2] 476934 476890 476852 476813 476799 ... ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;POLYGON&quot; &quot;sfg&quot; ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;STTLNR&quot; &quot;STTLNAME&quot; Eine Vorschau: ggplot(stadtteile) + geom_sf() + geom_sf_label(aes(label = STTLNAME), size = 2) 6.5 OSM-Daten Im OSM Wiki suchen wir den richtigen tag heraus. In diesem Fall shop=kiosk Dann bauen wir auf Overpass Turbo die Abfrage und laden den Datensatz herunter. Schließlich importieren wir: kioske &lt;- st_read(&quot;resources/kioske.geojson&quot;) ## Reading layer `kioske&#39; from data source ## `/Users/till/mzs/2021_methodenwoche/skript/resources/kioske.geojson&#39; ## using driver `GeoJSON&#39; ## Simple feature collection with 325 features and 74 fields ## Geometry type: GEOMETRY ## Dimension: XY ## Bounding box: xmin: 8.505468 ymin: 50.04801 xmax: 8.789538 ymax: 50.20185 ## Geodetic CRS: WGS 84 Eine Vorschau: ggplot() + geom_sf(data = stadtteile) + geom_sf(data = kioske) 6.6 Koordinatenreferenzsysteme Der OSM-Datensatz ist mit WGS84 (EPSG 4326) referenziert: st_crs(kioske) ## Coordinate Reference System: ## User input: WGS 84 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]] Die Stadtteilen hingegen sind sind in ETSR89 (EPSG 25832): st_crs(stadtteile) ## Coordinate Reference System: ## User input: ETRS89 / UTM zone 32N ## wkt: ## PROJCRS[&quot;ETRS89 / UTM zone 32N&quot;, ## BASEGEOGCRS[&quot;ETRS89&quot;, ## DATUM[&quot;European Terrestrial Reference System 1989&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4258]], ## CONVERSION[&quot;UTM zone 32N&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,9, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.9996, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,500000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;Engineering survey, topographic mapping.&quot;], ## AREA[&quot;Europe between 6°E and 12°E: Austria; Belgium; Denmark - onshore and offshore; Germany - onshore and offshore; Norway including - onshore and offshore; Spain - offshore.&quot;], ## BBOX[38.76,6,83.92,12]], ## ID[&quot;EPSG&quot;,25832]] Der Datensatz lässt sich allerdings transformieren: stadtteile %&gt;% st_transform(4326) %&gt;% st_crs() ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;Horizontal component of 3D system.&quot;], ## AREA[&quot;World.&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] Jetzt haben beide Datensätze den selben EPSG-Code. Das ist die Voraussetzung für den nächsten Schritt. 6.7 Verschneiden Mit st_covers() und lengths() lassen sich die Anzahl der Kioske in jedem Stadtteil zählen und einer neuen Spalte im Originaldatensatz zuordnen: stadtteile %&gt;% st_transform(4326) %&gt;% st_covers(kioske) %&gt;% lengths() -&gt; stadtteile$anzahl_kioske Auf einer Karte veranschaulicht: ggplot(stadtteile) + geom_sf(aes(fill = anzahl_kioske)) Allerdings wäre es schöner, die Kioskdichte (nach Fläche) darzustellen. Dazu berechnen wir zunächst die Flächen der Stadtteile: st_area(stadtteile) %&gt;% as.numeric() / 1000 / 1000 -&gt; stadtteile$qkm Oder mit Pipes: stadtteile %&gt;% mutate(qkm = st_area(.) %&gt;% as.numeric() / 1000 / 1000) ## Simple feature collection with 46 features and 4 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 462292.7 ymin: 5540412 xmax: 485744.8 ymax: 5563925 ## Projected CRS: ETRS89 / UTM zone 32N ## First 10 features: ## STTLNR STTLNAME geometry anzahl_kioske ## 1 1 Altstadt POLYGON ((476934.3 5550541,... 5 ## 2 2 Innenstadt POLYGON ((477611.9 5552034,... 5 ## 3 3 Bahnhofsviertel POLYGON ((475831 5550785, 4... 7 ## 4 4 Westend-Süd POLYGON ((475745.4 5552373,... 6 ## 5 5 Westend-Nord POLYGON ((476497.9 5553910,... 3 ## 6 6 Nordend-West POLYGON ((478362.5 5553898,... 10 ## 7 7 Nordend-Ost POLYGON ((478397.9 5551924,... 17 ## 8 8 Ostend POLYGON ((481955.2 5552141,... 15 ## 9 9 Bornheim POLYGON ((478959.8 5552336,... 14 ## 10 10 Gutleutviertel POLYGON ((472942 5548802, 4... 11 ## qkm ## 1 0.5065673 ## 2 1.4902009 ## 3 0.5425421 ## 4 2.4948957 ## 5 1.6307925 ## 6 3.0977694 ## 7 1.5305338 ## 8 5.5573382 ## 9 2.7840413 ## 10 2.1982354 Und dann die Kioskdichte: stadtteile %&gt;% mutate(qkm = st_area(.) %&gt;% as.numeric() / 1000 / 1000, kioskdichte = anzahl_kioske / qkm) ## Simple feature collection with 46 features and 5 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 462292.7 ymin: 5540412 xmax: 485744.8 ymax: 5563925 ## Projected CRS: ETRS89 / UTM zone 32N ## First 10 features: ## STTLNR STTLNAME geometry anzahl_kioske ## 1 1 Altstadt POLYGON ((476934.3 5550541,... 5 ## 2 2 Innenstadt POLYGON ((477611.9 5552034,... 5 ## 3 3 Bahnhofsviertel POLYGON ((475831 5550785, 4... 7 ## 4 4 Westend-Süd POLYGON ((475745.4 5552373,... 6 ## 5 5 Westend-Nord POLYGON ((476497.9 5553910,... 3 ## 6 6 Nordend-West POLYGON ((478362.5 5553898,... 10 ## 7 7 Nordend-Ost POLYGON ((478397.9 5551924,... 17 ## 8 8 Ostend POLYGON ((481955.2 5552141,... 15 ## 9 9 Bornheim POLYGON ((478959.8 5552336,... 14 ## 10 10 Gutleutviertel POLYGON ((472942 5548802, 4... 11 ## qkm kioskdichte ## 1 0.5065673 9.870357 ## 2 1.4902009 3.355252 ## 3 0.5425421 12.902225 ## 4 2.4948957 2.404910 ## 5 1.6307925 1.839596 ## 6 3.0977694 3.228129 ## 7 1.5305338 11.107236 ## 8 5.5573382 2.699134 ## 9 2.7840413 5.028661 ## 10 2.1982354 5.004014 Schließlich die Karte: stadtteile %&gt;% mutate(qkm = st_area(.) %&gt;% as.numeric() / 1000 / 1000, kioskdichte = anzahl_kioske / qkm) %&gt;% ggplot() + geom_sf(aes(fill = kioskdichte), color=NA) + scale_fill_continuous(&quot;Kioske pro km²&quot;) + theme_void() 6.8 Aufgaben Erstellen Sie eine Choroplethenkarte der Frankfurter Stadtteile, in der Sie die Anzahl bzw. die Dichte von Apotheken darstellen. (Schritte analog zu oben.) # Aus dem OSM-Wiki erfahren wir, dass die Abfrage lautet: amenity=pharmacy # Auf Overpass Turbo lässt sich das Resultat als geoJSON exportieren. stadtteile %&gt;% st_transform(4326) %&gt;% st_covers(st_read(&quot;resources/apotheken.geojson&quot;)) %&gt;% lengths() -&gt; stadtteile$anzahl_apotheken ## Reading layer `apotheken&#39; from data source ## `/Users/till/mzs/2021_methodenwoche/skript/resources/apotheken.geojson&#39; ## using driver `GeoJSON&#39; ## Simple feature collection with 257 features and 61 fields ## Geometry type: GEOMETRY ## Dimension: XY ## Bounding box: xmin: 8.466004 ymin: 50.04214 xmax: 8.834962 ymax: 50.21252 ## Geodetic CRS: WGS 84 stadtteile %&gt;% mutate(qkm = st_area(.) %&gt;% as.numeric() / 1000 / 1000, apothekendichte = anzahl_apotheken/ qkm) %&gt;% ggplot() + geom_sf(aes(fill = apothekendichte), color = NA) + scale_fill_continuous(&quot;Apotheken pro km²&quot;) Welche Stadtteile haben mehr Kioske? Welche mehr Apotheken? Wie ausgeprägt ist das Verhältnis? Erstellen Sie eine Karte, die das zum Ausdruck bringt. stadtteile %&gt;% mutate(ratio = (anzahl_apotheken - anzahl_kioske) / (anzahl_apotheken + anzahl_kioske)) %&gt;% ggplot() + geom_sf(aes(fill = ratio), color=NA) + scale_fill_continuous(NULL, type = &quot;viridis&quot;, breaks = seq(1, -1, -0.5), labels = c(&quot;nur Apotheken&quot;, &quot;mehr Apotheken&quot;, &quot;gleiche Anzahl&quot;, &quot;mehr Kioske&quot;, &quot;nur Kioske&quot;)) + theme_void() (Achtung, knifflig!) Siemens veröffentlicht einen Blitzatlas. Laden Sie den Datensatz herunter und bauen Sie die folgende Ansicht nach: &quot;resources/Uebersicht-Blitzeinschlaege-2019.xlsx&quot; %&gt;% readxl::read_excel() %&gt;% rowwise() %&gt;% mutate(Dichte2016 = `Dichte 2016`, DichteGesamt = mean(c(Dichte2015, Dichte2016, Dichte2017, Dichte2018, Dichte2019)), kreis = `Stadt- oder Landkreis` %&gt;% str_remove(&quot;(LK) |(SK) &quot;)) %&gt;% select(-`Dichte 2016`) %&gt;% pivot_longer(starts_with(&quot;Dichte&quot;), names_prefix = &quot;Dichte&quot;, names_to = &quot;Jahr&quot;, values_to = &quot;Blitzdichte&quot;) %&gt;% select(kreis, Jahr, Blitzdichte) -&gt; blitze # Landkreise gibt es z. B. vom GDZ: https://gdz.bkg.bund.de/ # Datensatz: Verwaltungsgebiete 1:250 000 mit Einwohnerzahlen (Ebenen) &quot;resources/vg250-ew_3112.gk3.shape.ebenen/vg250-ew_ebenen_3112/VG250_KRS.shp&quot; %&gt;% read_sf() %&gt;% filter(str_detect(RS, &quot;^06&quot;)) %&gt;% left_join(blitze, by = c(&quot;GEN&quot; = &quot;kreis&quot;)) %&gt;% ggplot() + geom_sf(aes(fill = Blitzdichte), color=NA) + facet_wrap(~Jahr) + scale_fill_continuous(type=&quot;viridis&quot;) + theme(axis.ticks = element_blank(), axis.text = element_blank(), panel.grid = element_blank()) "],["weitere-methoden.html", "Teil 7 Weitere Methoden 7.1 Vorbereitung 7.2 Aufgabe 7.3 Daten einlesen 7.4 Überblick verschaffen 7.5 Zusammenfassen 7.6 Verschneiden 7.7 Kartieren 7.8 Choroplethen 7.9 Räumliches Verschneiden", " Teil 7 Weitere Methoden 7.1 Vorbereitung Für diese Lektion brauchen wir folgende Pakete: library(tidyverse) library(sf) library(tmap) 7.2 Aufgabe Ziel soll sein, eine Deutschlandkarte mit Tankstellenpreisen für Diesel zu erstellen. 7.3 Daten einlesen Das Tankerkönig-Projekt veröffentlicht aktuelle Tankstellenpreise über eine API, und stellt historische Preise hier bereit: https://dev.azure.com/tankerkoenig/_git/tankerkoenig-data Wir laden die Dateien für prices und stations von einem Tag (hier: 26.5.2019) herunter und speichern sie im Unterordner resources des Projektordners. Dann können wir sie einlesen: preise &lt;- read_csv(&quot;resources/2019-05-26-prices.csv&quot;) preise ## # A tibble: 231,174 x 8 ## date station_uuid diesel e5 e10 dieselchange e5change ## &lt;dttm&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019-05-25 22:01:06 51e171d0-1a9c-4… 1.37 1.58 1.56 1 1 ## 2 2019-05-25 22:02:06 8a796af1-8d78-4… 1.32 1.56 1.54 1 1 ## 3 2019-05-25 22:02:06 2d658127-11b5-4… 1.28 1.52 0 0 1 ## 4 2019-05-25 22:03:06 904d3a45-df30-4… 1.32 1.54 1.52 1 1 ## 5 2019-05-25 22:03:06 a98ed5d0-261b-4… 1.34 1.57 1.55 1 1 ## 6 2019-05-25 22:04:06 7671d5ad-4c7d-4… 1.30 1.54 0 1 1 ## 7 2019-05-25 22:04:06 44fa4d12-5571-4… 1.34 1.58 1.56 1 1 ## 8 2019-05-25 22:04:06 da9abcda-3218-4… 1.38 1.52 1.50 0 1 ## 9 2019-05-25 22:04:06 bcba0c2b-fbe7-4… 1.35 1.55 1.53 0 1 ## 10 2019-05-25 22:04:06 00061000-0001-4… 1.20 1.48 1.46 1 1 ## # … with 231,164 more rows, and 1 more variable: e10change &lt;dbl&gt; 7.4 Überblick verschaffen Beim nähreren Betrachten fällt auf, dass im Datensatz preise 231.174 Zeilen enthalten sind, in stations nur 15.668. Das liegt daran, das für jede Station mehrere Preisupdates im Datensatz preise stehen, jedoch nur einmal die gleichbleibenden Informationen (Name, Marke, Adresse, Koordinaten) in stations. Beide Datensätze sind über einen eindeutigen „Key“ verbunden: In preise heißt er station_uuid, in stations einfach nur uuid. Um ein besseres Gefühl für den Datensatz zu bekommen, könnten wir uns z. B. anschauen, zu welcher Uhrzeit wie viele Preise aktualisiert wurden: ggplot(preise) + geom_histogram(aes(x = date)) 7.5 Zusammenfassen Eine weitere Frage könnte sein: Wie sieht die Verteilung der Anzahl der Preisupdates je Tankstelle aus? Hierfür müssen wir den Datensatz preise anhand der Spalte station_uuid zusammenfassen und die Einträge zählen. Das geht mit group_by() und summarize(): preise %&gt;% group_by(station_uuid) %&gt;% summarize(anzahl_updates = n()) %&gt;% ggplot() + geom_histogram(aes(x = anzahl_updates)) Um unserem Ziel der Dieselkarte etwas näher zu kommen, sollten wir aber nicht die Anzahl der Updates zusammenfassen, sondern den Dieselpreis. Aber nach welchem Schema? Einfach nur den Durchschnitt (mit mean()) zu nehmen, könnte das Bild verfälschen: Man stelle sich z. B. vor, ein besonders teurer (oder günstiger) Preis sei nur wenige Sekunden gültig gewesen. Wir orientieren uns einfach an der Börse und nehmen einfach den letzten gültigen Preis (wie der Aktienwert bei Börsenschluss). Dafür müssen wir den Datensatz erst mit arrange() chronologisch sortieren, dann entsprechend gruppieren und mit last() zusammenfassen: preise %&gt;% arrange(date) %&gt;% group_by(station_uuid) %&gt;% summarize(dieselpreis = last(diesel), e5preis = last(e5), e10preis = last(e10)) -&gt; preise_nach_tankstelle preise_nach_tankstelle ## # A tibble: 13,701 x 4 ## station_uuid dieselpreis e5preis e10preis ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 00006210-0037-4444-8888-acdc00006210 1.33 1.55 1.53 ## 2 00016899-3247-4444-8888-acdc00000007 1.31 1.53 1.51 ## 3 00060001-d387-4444-8888-acdc00000001 1.37 1.62 1.60 ## 4 00060009-3adf-4444-8888-acdc00000001 1.35 1.64 1.62 ## 5 00060014-b0d9-4444-8888-acdc00000002 1.32 1.61 1.59 ## 6 00060015-0090-4444-8888-acdc00000090 1.27 1.52 1.50 ## 7 00060016-ed96-4444-8888-acdc00000001 1.35 1.57 1.55 ## 8 00060034-0011-4444-8888-acdc00000011 1.37 1.61 1.59 ## 9 00060051-533e-75a1-87f9-8a9f00060051 1.25 1.50 1.48 ## 10 00060055-0001-4444-8888-acdc00000001 1.26 1.53 1.51 ## # … with 13,691 more rows 7.6 Verschneiden Jetzt haben wir für jede Station nur noch eine Zeile mit den Preisen. Um das zu kartieren, fehlen noch die Informationen zu den Tankstellen. Dafür laden wir auch den stations-Datensatz für den richtigen Tag herunter und importieren ihn in R: tankstellen &lt;- read_csv(&quot;resources/2019-05-26-stations.csv&quot;) tankstellen ## # A tibble: 15,668 x 11 ## uuid name brand street house_number post_code city latitude longitude ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0e18d0… OIL! T… OIL! Evers… &lt;NA&gt; 80999 Münc… 48.2 11.5 ## 2 ad8122… bft Bo… bft Godes… 55 53175 Bonn 50.7 7.14 ## 3 44e2bd… bft Ta… &lt;NA&gt; Schel… 53 36304 Alsf… 50.8 9.28 ## 4 1a8e4d… Hessol Hessol Frank… 65 61279 Gräv… 50.4 8.46 ## 5 005056… star T… STAR Leipz… 11 06217 Mers… 51.4 12.0 ## 6 d435f7… ROSDOR… Shell A7 GÖ… &lt;NA&gt; 37124 Rosd… 51.5 9.88 ## 7 88a23d… AVIA T… AVIA Burgs… 8 63637 Joss… 50.2 9.48 ## 8 f0e93f… Aral T… ARAL Eicke… 357 41063 Mönc… 51.2 6.45 ## 9 005056… star T… STAR Celle… 55 29303 Berg… 52.8 9.97 ## 10 8e47dd… Aral T… ARAL Crail… 32 74532 Ilsh… 49.2 9.93 ## # … with 15,658 more rows, and 2 more variables: first_active &lt;dttm&gt;, ## # openingtimes_json &lt;chr&gt; Wir verschneiden mit inner_join() unter Angabe der relevanten Spaltennamen und wählen die Spalten aus, mit denen wir weiterarbeiten wollen: inner_join(preise_nach_tankstelle, tankstellen, by = c(&quot;station_uuid&quot; = &quot;uuid&quot;)) %&gt;% select(dieselpreis, e5preis, e10preis, name, brand, latitude, longitude) -&gt; preise_geo preise_geo ## # A tibble: 13,700 x 7 ## dieselpreis e5preis e10preis name brand latitude longitude ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.33 1.55 1.53 Beducker - Quali… Beducker 48.6 10.9 ## 2 1.31 1.53 1.51 Röttenbach BFT Pickel… 49.7 10.9 ## 3 1.37 1.62 1.60 Haisch Mineralöl… TankCenter… 48.0 7.59 ## 4 1.35 1.64 1.62 Tank-Kontor Wilh… &lt;NA&gt; 47.9 9.42 ## 5 1.32 1.61 1.59 Tank-Kontor Baie… &lt;NA&gt; 47.8 9.65 ## 6 1.27 1.52 1.50 Schindele, Lochb… &lt;NA&gt; 47.7 9.53 ## 7 1.35 1.57 1.55 bft-Tankstelle H… BFT 48.1 7.78 ## 8 1.37 1.61 1.59 EXTROL Tank- &amp; W… EXTROL 48.0 7.79 ## 9 1.25 1.50 1.48 Wingenfeld Energ… Wingenfeld… 50.8 10.2 ## 10 1.26 1.53 1.51 Wilhlem Heim GmbH Oel - Heim 48.6 9.03 ## # … with 13,690 more rows inner_join hat die Besonderheit, dass nur Zeilen im kombinierten Datensatz übrigbleiben, deren Key in beiden Datensätzen gefunden wurde. Mit left_join würden hier alle Preise behalten werden (und die fehlenden Koordinaten mit NA ergänzt), mit right_join würden alle Stationen behalten werden (und fehlende Preise mit NA ergänzt). full_join löscht gar keine Informationen. 7.7 Kartieren Den georeferenzierten Datensatz der Preise wandeln wir in eine Simple Feature Collection um: preise_geo %&gt;% st_as_sf(coords = c(&quot;longitude&quot;, &quot;latitude&quot;)) -&gt; preise_sf ggplot() kartiert so einen großen Datensatz nur langsam. Wir nehmen stattdessen das Paket tmap() zur Hand, das mit einer ähnlichen Grammatik funktioniert. Interaktive Karten lassen sich mit tmap produzieren, wenn die Option tmap_mode(&quot;view&quot;) gesetzt ist. Aus technischen Gründen wird an dieser Stelle im Skript darauf verzichtet und wir bleiben beim plot-Modus: tm_shape(preise_sf) + tm_dots() Zwei Koordinaten sind quatsch! Wir finden ihre ungefähren Werte mit summary: summary(preise_geo$longitude) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 5.901 8.021 9.275 9.607 11.058 97.364 Und filtern sie raus, und wiederholen die Umwandlung (diesmal auch mit CRS) preise_geo %&gt;% filter(longitude &lt; 80) %&gt;% st_as_sf(coords = c(&quot;longitude&quot;, &quot;latitude&quot;)) %&gt;% st_set_crs(4326) -&gt; preise_sf Dann mappen wir nochmal: tm_shape(preise_sf) + tm_dots(&quot;dieselpreis&quot;, style = &quot;cont&quot;) Schon ganz hübsch, aber die Skala wird nun verzerrt durch sehr teure Autobahntankstellen einerseits, und falsche Null-werte andererseits: summary(preise_sf$dieselpreis) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000 1.249 1.289 1.290 1.329 1.679 7.8 Choroplethen Eine Lösung wäre, die Daten auf Kreisebene zusammenzufassen, und zwar anhand ihres Medians. Damit würden diese Ausreißer keine Role mehr spielen. Das eurostat-Paket macht es einfach, diese Geodaten einzulesen. NUTS3 ist die Ebene der Stadt- und Landkreise bzw. ihrer europäischen Equivalente. kreise &lt;- eurostat::get_eurostat_geospatial(nuts_level = 3) %&gt;% filter(CNTR_CODE == &quot;DE&quot;) Mal schauen wie es aussieht: tm_shape(kreise) + tm_polygons() 7.9 Räumliches Verschneiden mit st_join werden Datensätze nicht mit einem Key verschnitten, sondern anhand ihrer Geolokation. Dann können wir wieder ganz normal group_by und summarise verwenden: st_join(kreise, preise_sf) %&gt;% group_by(NUTS_ID) %&gt;% summarise(dieselpreis = median(dieselpreis), e5preis = median(e5preis), e10preis = median(e10preis)) -&gt; preise_kreise Und so könnte vielleicht ein vorläufiges Ergebnis aussehen: tm_shape(preise_kreise) + tm_fill(&quot;dieselpreis&quot;, title = &quot;Median der Dieselpreise&quot;, style = &quot;cont&quot;, alpha = 0.8) + tm_layout(legend.outside = TRUE) "],["publizieren-und-nach-hilfe-fragen.html", "Teil 8 Publizieren und nach Hilfe fragen 8.1 Publizieren mit Rmarkdown 8.2 Nach Hilfe fragen", " Teil 8 Publizieren und nach Hilfe fragen 8.1 Publizieren mit Rmarkdown 8.1.1 Text formatieren Wir arbeiten schon von Anfang an mit im Rmarkdown-Format. Wie Überschriften, Links, Bilder usw. in Rmarkdown genau funktionieren, ist in dieser Übersicht und auf diesem Cheat Sheet gut festgehalten. 8.1.2 Der Knit-Button Wenn wir im YAML-Header die Zeile output: html_document setzen, erscheint (nach Abspeichern) ein „Knit“-Button in der GUI. Durch Drücken auf diesen Knopf passiert folgendes: R erstellt („strickt“) ein HTML-Dokument aus dem vorliegenden Markdown und den Code Chunks Dabei spielen „gespeicherte“ Objekte keine Rolle, die Chunks werden einfach der Reihe nach (in einem neuen Environment) ausgeführt Externe Datensätze o. ä. müssen also am Anfang des Dokuments explizit geladen werden (etwa mit load()). Für den Abschlussbericht ist es ratsam, einen vorbereiteten Datensatz am Anfang des Rmarkdown-Dokuments so zu laden. Im YAML-Header können noch viele weitere Angaben gemacht werden, die das Resultat verändern. Hier eine gute Dokumentation: https://bookdown.org/yihui/rmarkdown/html-document.html 8.1.3 Kable Im knitr-Paket sorgt der Befehl kable() für eine schöne Darstellung von Tabellen: ggplot2::diamonds %&gt;% head() %&gt;% knitr::kable() carat cut color clarity depth table price x y z 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 0.29 Premium I VS2 62.4 58 334 4.20 4.23 2.63 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 Auch hier gibt es wieder vielfältige Möglichkeiten zur visuellen Gestaltung. Diesen Post finde ich immer besonders hilfreich: https://haozhu233.github.io/kableExtra/awesome_table_in_html.html 8.1.4 Chunk Options Am Anfang eines Code Chunks kann genau festgelegt werden, ob der Code ausgeführt werden soll, ob er im finalen Dokument erscheinen soll, ob Warnungen oder Fehler ausgegeben werden sollen, etc. Wenn zum Beispiel Libraries „versteckt“ geladen werden sollen, geht das mit diesem Code Chunk: ```{r, include = FALSE} library(tidyverse) library(rvest) ``` Ein überblick über die Chunk-Optionen findet sich hier: https://bookdown.org/yihui/rmarkdown/r-code.html 8.1.5 Reproducible research Wenn z. B. ein (längeres) Script einen (größeren) Datensatz generiert und ihn dem Objektnamen mein_datensatz zuweist, dann erscheint der Datensatz im lokalen Environment. Um den Datensatz mit anderen zu teilen, muss er irgendwie exportiert werden. Hierfür ist es ratsam, die save()-Funktion zu nutzen: save(mein_datensatz, file = &quot;zwischenstand_mein_datensatz.Rdata&quot;) So wird eine Datei erstellt, die den Datensatz enthält und verschoben oder geteilt werden kann. Eine solche Datei kann auch andere Objekte (Funktionen, Listen, …) und mehrere Objekte auf einmal enthalten. Die Dateiendung ist dabei eigentlich egal, .Rdata scheint aber Usus zu sein. Aus der Datei können Objekte dann jederzeit wieder ins Environment geladen werden mit dem Befehl: load(&quot;zwischenstand_mein_datensatz.Rdata&quot;) Auch wenn ein Skript auf einmal nicht mehr funktioniert (etwa weil die API sich ändert), ist es hilfreich, auf solche Zwischenstände zurückgreifen zu können. 8.1.6 Wissenschaftliches Zitieren Wer die Vorzüge von Literaturverwaltungssoftware (wie Citavi, Zotero, …) schon schätzen gelernt hat, kann in Rmarkdown folgendermaßen vorgehen: 8.1.6.1 Schritt 1: Exportieren Die relevante Literatur in eine BibTex-Datei im R-Arbeitsverzeichnis exportieren, z.B. literatur.bib. BibTex (bzw. BibLatex) ist ein bewährtes und gut dokumentiertes Format. Ein Eintrag sieht dann z.B. so aus, wobei bortz der „Name“ des Eintrags ist, den wir frei wählen können: @book{bortz, author = {Bortz, J{\\&quot;u}rgen and Schuster, Christof}, title = {{Statistik f{\\&quot;u}r Human- und Sozialwissenschaftler}}, publisher = {Springer}, year = {2010}, address = {Berlin}, edition = {7}, } 8.1.6.2 Schritt 2: Verlinken Im YAML-Header des Rmarkdown-dokuments die Angabe ergänzen: bibliography: literatur.bib Damit weiß der „Knit“-Befehl, wo er nach Literatur suchen soll. 8.1.6.3 Schritt 3: Zitieren Im Text kann dann z. B. so zitiert werden: Das zentrale Grenzwerttheorem besagt, dass die Stichprobenverteilung von $\\bar{x}$ mit steigender Stichprobengröße $n$ in eine Normalverteilung übergeht [@bortz: 86]. 8.1.6.4 Schritt 4: Stricken Beim „Knit“-Befehl wird ein Literaturverzeichnis automatisch erstellt und ans Ende des Dokuments gehängt. Deshalb beendet man das Dokument am besten mit der Zeile: ## Literaturverzeichnis 8.2 Nach Hilfe fragen Online-Foren, insb. Stackoverflow sind tolle Ressourcen um Probleme beim Programmieren zu lösen. (Weniger bekannt: die Statistik-Schwesterseite Cross Validated.) Oft landet man auf Stackoverflow, wenn man nach einer Fehlermeldung oder einer Problemstellung googelt. Aber obwohl die Stackoverflow-Community den Ruf hat, sehr streng zu sein und Hilfegesuche einfach abzubügeln, ist es gar nicht so verkehrt hier nach Hilfe auch zu komplexen Problemen zu fragen. Um hilfreiches Feedback zu bekommen, lohnt es sich jedoch, einige Punkte zu beachten: Fragen können mit Stichworten getaggt werden. Neben dem Tag R lohnt es sich, konkrete Pakete wie ggplot2, sf o. ä. zu taggen, damit die richtigen Personen darauf aufmerksam werden. Ein ganz kurzer einleitender Satz zum Kontext sollte nicht fehlen: I’m trying to … in order to … Wenn es eine existierende Frage oder eine Online-Ressource gibt, die dem Problem sehr ähnlich ist (aber nicht ganz auf den Fall passt), ist es ratsam darauf zu verweisen: I already tried this solution, but my problem is … Kurze, reproduzierbare Beispiele helfen den Antwortenden dabei, mögliche Lösungen auszuprobieren und zu testen. Dabei ist es oft sinnvoll, kurze Auszüge von Datensätzen in die Frage einzubauen – und zwar so, dass sie einfach in R kopiert werden können. Das geht oft ganz gut mit dput(head(DATENSATZ)). Weitere Infos dazu: https://stackoverflow.com/questions/5963269/how-to-make-a-great-r-reproducible-example#5963610 Schließlich ist es hilfreich deutlich zu machen, was das unmittelbare Ziel des Codes ist: My expected output should look like this: … "]]
